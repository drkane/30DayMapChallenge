<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
  fill: #ddd;
  fill-opacity: .8;
  stroke: #fff;
  stroke-width: 1.5px;
}

line {
  stroke: #999;
}

.tooltip {
    position: absolute;
    font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 10px;
    padding: 2px;
    background-color: aqua;
}

</style>
<body>
<script src="//d3js.org/d3.v5.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
<script>

function round(p, n) {
    return p % n < n / 2 ? p - (p % n) : p + n - (p % n);
}

// const CSV_FILE = "data/Middle_Layer_Super_Output_Areas__December_2011__Boundaries_EW_BFC.csv"
const CSV_FILE = "data/Local_Authority_Districts__May_2020__UK_BUC.csv"
const HEX_RADIUS = 4;
const COLUMN_LAT = "LAT"
const COLUMN_LNG = "LONG"
const COLUMN_TITLE = "LAD20NM"
// const COLUMN_TITLE = "MSOA11NM"
// const COLUMN_ID = "MSOA11CD"

var width = 960,
    height = 960,
    resolution = 5;


var projection = d3.geoMercator().scale(1600).center([0,56]),
    path = d3.geoPath().projection(projection),
    hexbin = d3.hexbin();
    // force = d3.layout.force().size([width, height]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0)
    .style("position", "absolute");

d3.csv(CSV_FILE).then(function(las){
    hexbin.radius(HEX_RADIUS);
    const nodes = las.map(function(d) {
        lat_lng = projection([d[COLUMN_LNG], d[COLUMN_LAT]]);
        return {
            x: lat_lng[0],
            y: lat_lng[1],
            title: d[COLUMN_TITLE],
        }
    });

    var nodes_display = svg.selectAll("path.area")
        .data(nodes)
        .enter()
        .append("path")
        .style("fill", "#ff0000")
        .style("stroke", "#ff0000")
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
        .attr("d", hexbin.hexagon())

    function ticked() {
        nodes_display
            .attr("transform", function(d) {
                var x = round(Math.max(HEX_RADIUS, Math.min(width - HEX_RADIUS, d.x)), resolution);
                var y = round(Math.max(HEX_RADIUS, Math.min(height - HEX_RADIUS, d.y)), resolution);
                return "translate(" + d.x + "," + d.y + ")";
            })
            .attr("d", hexbin.hexagon())
            .on("mouseover", function(d) {		
                div.transition()		
                    .duration(200)		
                    .style("opacity", .9);		
                div.html(d.title)
                    .style("left", (d3.event.pageX) + "px")		
                    .style("top", (d3.event.pageY - 28) + "px");
                });
    }
    
    const simulation = d3.forceSimulation(nodes)
        .alphaTarget(0)
        .velocityDecay(0.7)
        // .force("x", d3.forceX().strength(0.01))
        // .force("y", d3.forceY().strength(0.01))
        .force("collide", d3.forceCollide().radius(HEX_RADIUS).iterations(3))
        .force('charge', d3.forceManyBody().strength(0.01))
        .on("tick", ticked);

});

</script>
